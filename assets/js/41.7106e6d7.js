(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{517:function(e,n,t){"use strict";t.r(n);var a=t(2),o=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"前端跨页面通信"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前端跨页面通信"}},[e._v("#")]),e._v(" 前端跨页面通信")]),e._v(" "),n("h2",{attrs:{id:"背景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[e._v("#")]),e._v(" 背景")]),e._v(" "),n("p",[e._v("用户在实际的操作场景中会打开多个 Tab 页面A、B、C、D、E...。当用户在 E Tab 页退出登录，并且登录到新的账号，然后用户切换到非 E 的 Tab 时，发现登录信息没有刷新， 并且由于登录信息没有刷新，会出现操作异常。这个问题简单来说就是多个 Tab 信息没有同步。问题的关键在于一个 Tab 退出重新登录，需要通知到其他的 Tab 刷新到最新的信息。本质问题就是"),n("strong",[e._v("解决前端跨页面通信")]),e._v("。")]),e._v(" "),n("p",[e._v("本篇文章就是对前端跨页面通信的解决方案做了一个了解。")]),e._v(" "),n("h2",{attrs:{id:"onstorage"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#onstorage"}},[e._v("#")]),e._v(" onstorage")]),e._v(" "),n("p",[e._v("WindowEventHandlers.onstorage 属性包含一个在 storage 事件触发时运行的事件处理程序。当更改存储时会触发事件处理程序。")]),e._v(" "),n("h3",{attrs:{id:"语法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[e._v("#")]),e._v(" 语法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("window.onstorage = function（）{...};\n                              \nwindow.onstorage = function(e) {\n  console.log(`The ${e.key}  key has been changed from ${e.oldValue}  to  ${e.newValue} .`);\n};\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<div id=\"app\"></div>\n<button id=\"tab\">新开 Tab</button>\n<button id=\"l-btn\">触发 LocalStorage 更新</button>\n<button id=\"s-btn\">触发 SessionStorage 更新</button>\n<script>\n  window.onstorage = function(e) {\n    console.log(`The ${e.key}  key has been changed from ${e.oldValue}  to  ${e.newValue} .`);\n  };\n\n  document.getElementById('tab').onclick = function () {\n    window.open('xxx');\n  }\n\n  document.getElementById('l-btn').onclick = function () {\n    localStorage.setItem('storage1', Date.now())\n  }\n\n  document.getElementById('s-btn').onclick = function () {\n    sessionStorage.setItem('storage1', Date.now())\n }\n<\/script>\n\n")])])]),n("p",[n("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d705b1fcf685468ca1172c288f8e212a~tplv-k3u1fbpfcp-zoom-1.image",alt:"onstorage.gif"}})]),e._v(" "),n("p",[n("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6e172b8233a4d8b8afe9f17cb5b82b4~tplv-k3u1fbpfcp-zoom-1.image",alt:"onstorage1.gif"}})]),e._v(" "),n("h3",{attrs:{id:"tips"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#tips"}},[e._v("#")]),e._v(" Tips")]),e._v(" "),n("ol",[n("li",[e._v("该事件不在导致数据变化的当前页面触发（如果浏览器同时打开一个域名下面的多个页面，当其中的一个页面改变 数据时，其他所有页面的 storage 事件会被触发，而原始页面并不触发 storage 事件）。")]),e._v(" "),n("li",[e._v("sessionStorage（❎）不能触发 storage 事件 ， localStorage（✅）可以。")]),e._v(" "),n("li",[e._v("如果修改的值未发生改变，将不会触发 onstorage 事件。")]),e._v(" "),n("li",[e._v("优点：浏览器支持效果好、API直观、操作简单。缺点：部分浏览器隐身模式下，无法设置 localStorage。如safari，这样也就导致 onstrage 事件无法使用。")])]),e._v(" "),n("blockquote",[n("p",[e._v("除开少数情况，localStorage的兼容性不错，就当前国内的情况，已经基本没有问题了。localStorage 的原理很简单，浏览器为每个域名划出一块本地存储空间，用户网页可以通过 localStorage 命名空间进行读写。"),n("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a475fdf9867443c4baa1ddb91dacc1db~tplv-k3u1fbpfcp-zoom-1.image",alt:"onstorage兼容性.png"}})])]),e._v(" "),n("h2",{attrs:{id:"broadcast-channel"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#broadcast-channel"}},[e._v("#")]),e._v(" BroadCast Channel")]),e._v(" "),n("p",[e._v("BroadcastChannel 接口代理了一个命名频道，"),n("strong",[e._v("可以让指定 origin 下的任意 browsing context 来订阅它。它允许同源的不同浏览器窗口，Tab页，frame或者 iframe 下的不同文档之间相互通信")]),e._v("。通过触发一个 message 事件，消息可以广播到所有监听了该频道的 BroadcastChannel 对象。")]),e._v(" "),n("p",[e._v("说到 BroadCast Channel 不得不说一下 postMessage，他们二者的最大区别就在于 postMessage 更像是点对点的通信，而 BroadCast Channel 是广播的方式，点到面。")]),e._v(" "),n("h3",{attrs:{id:"语法-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#语法-2"}},[e._v("#")]),e._v(" 语法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 创建\nconst broadcastChannel = new BroadcastChannel('channelName');\n\n// 监听消息\nbroadcastChannel.onmessage = function(e) {\n    console.log('监听消息:', e.data);\n};\n\n// 发送消息\nbroadcastChannel.postMessage('测试：传送消息');\n\n// 关闭\nbroadcastChannel.close();\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<div id=\"app\"></div>\n  <button id=\"tab\">新开 Tab</button>\n  <button id=\"l-btn\">发送消息</button>\n  <button id=\"s-btn\">关闭</button>\n  <script>\n    // 创建\n    const broadcastChannel = new BroadcastChannel('channelName');\n\n    // 监听消息\n    broadcastChannel.onmessage = function(e) {\n        console.log('监听消息:', e.data);\n    };\n\n    document.getElementById('tab').onclick = function () {\n      window.open('xxx');\n    }\n\n    document.getElementById('l-btn').onclick = function () {\n      // 发送消息\n      broadcastChannel.postMessage('测试，传送消息，我发送消息啦。。。');\n    }\n\n    document.getElementById('s-btn').onclick = function () {\n      // 关闭\n      broadcastChannel.close();\n    }\n\n  <\/script>\n\n")])])]),n("p",[n("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6851121a48714918be739dc8ad88aa47~tplv-k3u1fbpfcp-zoom-1.image",alt:"Broadcast Channel.gif"}})]),e._v(" "),n("p",[n("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5648e81a30aa4611b6c262f49ae7fcd8~tplv-k3u1fbpfcp-zoom-1.image",alt:"Broadcast Channel1.gif"}})]),e._v(" "),n("h3",{attrs:{id:"tips-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#tips-2"}},[e._v("#")]),e._v(" Tips")]),e._v(" "),n("ol",[n("li",[e._v("监听消息除了 .onmessage 这种方式，还可以 使用addEventListener来添加'message'监听，")]),e._v(" "),n("li",[e._v("关闭除了使用 Broadcast Channel 实例为我们提供的 close 方法来关闭 Broadcast Channel。我们还可取消或者修改相应的'message'事件监听。两者是有区别的：取消'message'监听只是让页面不对广播消息进行响应，Broadcast Channel 仍然存在；而调用 close 方法会切断与 Broadcast Channel 的连接，浏览器才能够尝试回收该对象，因为此时浏览器才会知道用户已经不需要使用广播频道了。")]),e._v(" "),n("li",[e._v("兼容性：如果不使用 IE 和 sf on iOS 浏览器，兼容性还是可以的。")])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a33f43cb3154d5082bcb4c4a1819ef0~tplv-k3u1fbpfcp-zoom-1.image",alt:"BroadCast Channel兼容性.png"}})]),e._v(" "),n("h2",{attrs:{id:"service-worker"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#service-worker"}},[e._v("#")]),e._v(" Service Worker")]),e._v(" "),n("p",[e._v("Service Worker 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面共享间的 Service Worker 可以共享，将 Service Worker 作为消息的处理中心（中央站）即可实现广播效果。")]),e._v(" "),n("h3",{attrs:{id:"语法-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#语法-3"}},[e._v("#")]),e._v(" 语法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<div id=\"app\"></div>\n<button id=\"tab\">新开 Tab</button>\n<button id=\"l-btn\">发送消息</button>\n<script>\n  /* 判断当前浏览器是否支持serviceWorker */\n  if ('serviceWorker' in navigator) {\n    /* 当页面加载完成就创建一个serviceWorker */\n    window.addEventListener('load', function () {\n      /* 创建并指定对应的执行内容 */\n      /* scope 参数是可选的，可以用来指定你想让 service worker 控制的内容的子目录。在这个例子里，我们指定了 '/'，表示 根网域下的所有内容。这也是默认值。*/\n      navigator.serviceWorker.register('./serviceWorker.js', { scope: './' })\n        .then(function (registration) {\n        console.log('ServiceWorker registration successful with scope: ', registration.scope);\n      })\n        .catch(function (err) {\n        console.log('ServiceWorker registration failed: ', err);\n      });\n    });\n\n    // 监听消息\n    navigator.serviceWorker.addEventListener('message', function (e) {\n      const data = e.data;\n      console.log('我接受到消息了：', data);\n    });\n\n    document.getElementById('l-btn').onclick = function () {\n      navigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage('测试，传送消息，我发送消息啦。。。');\n    };\n  }\n<\/script>\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/* 监听安装事件，install 事件一般是被用来设置你的浏览器的离线缓存逻辑 */\nthis.addEventListener('install', function (event) {\n  /* 通过这个方法可以防止缓存未完成，就关闭serviceWorker */\n  event.waitUntil(\n    /* 创建一个名叫V1的缓存版本 */\n    caches.open('v1').then(function (cache) {\n      /* 指定要缓存的内容，地址为相对于跟域名的访问路径 */\n      return cache.addAll(['./index.html']);\n    })\n  );\n});\n\n/* 注册fetch事件，拦截全站的请求 */\nthis.addEventListener('fetch', function (event) {\n  event.respondWith(\n    // magic goes here\n\n    /* 在缓存中匹配对应请求资源直接返回 */\n    caches.match(event.request)\n  );\n});\n\n/* 监听消息，通知其他 Tab 页面 */\nthis.addEventListener('message', function(event) {\n  this.clients.matchAll().then(function(clients) {\n    clients.forEach(function(client) {\n      // 这里的判断目的是过滤掉当前 Tab 页面，也可以使用 visibilityState 的状态来判断\n      if(!client.focused) {\n        client.postMessage(event.data)\n      }\n    })\n  })\n})\n\n")])])]),n("p",[n("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93564ceb89b14fecb5ee1df19eb6f481~tplv-k3u1fbpfcp-zoom-1.image",alt:"Service Worker.gif"}})]),e._v(" "),n("p",[n("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09a67a15b1e542a7a828e9d1c9b5ecb5~tplv-k3u1fbpfcp-zoom-1.image",alt:"Service Worker1.gif"}})]),e._v(" "),n("h3",{attrs:{id:"tips-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#tips-3"}},[e._v("#")]),e._v(" Tips")]),e._v(" "),n("ol",[n("li",[e._v("Service workers 本质上充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。所以本质上来说 Service Worker 并不自动具备“广播通信”的功能，需要改造 Service Worker 添加些代码，将其改造成消息中转站。在 Service Worker 中监听了message事件，获取页面发送的信息。然后通过 self.clients.matchAll() 获取当前注册了 Service Worker 的所有页面，通过调用每个的 postMessage 方法，向页面发送消息。这样就把从一处（某个Tab页面）收到的消息通知给了其他页面。")]),e._v(" "),n("li",[e._v("兼容性：IE 全军覆没，其他浏览器还行，整体来说一般。")])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c0477f909d3451e9155d1beabb1e30f~tplv-k3u1fbpfcp-zoom-1.image",alt:"Service Worker兼容性.png"}})]),e._v(" "),n("h2",{attrs:{id:"open-opener"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#open-opener"}},[e._v("#")]),e._v(" open & opener")]),e._v(" "),n("p",[e._v("当我们 系统中通过 window.open 打开一个新页面时，window.open 方法会返回一个被打开页面的引用，而被打开页面则可以通过 window.opener 获取到打开它的页面的引用（当然这是在没有指定noopener的情况下）。")]),e._v(" "),n("h3",{attrs:{id:"番外关于-noopener"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#番外关于-noopener"}},[e._v("#")]),e._v(" 番外关于 noopener")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<a href="https://google.com" target="_blank">Google</a>\n\n')])])]),n("p",[e._v("我们在系统中经常会这样使用 a 标签跳转到第三方网站，有时，当您单击网站上的链接时，该链接将在新选项卡中打开，但旧选项卡也会被重定向到其他网络钓鱼网站，它会要求您登录或开始将一些恶意软件下载到您的设备。这样存在一定的安全隐患，此时在新打开的页面中可通过 window.opener 获取到源页面的 window 对象， 这就埋下了安全隐患。 比如：")]),e._v(" "),n("ul",[n("li",[e._v("你自己的网站 A，点击如上链接打开了第三方网站 B。")]),e._v(" "),n("li",[e._v("此时网站 B 可以通过 window.opener 获取到 A 网站的 window 对象。")]),e._v(" "),n("li",[e._v("然后通过 window.opener.location.href = '"),n("a",{attrs:{href:"https://link.juejin.cn/?target=http%3A%2F%2Fwww.baidu.com",title:"http://www.baidu.com",target:"_blank",rel:"noopener noreferrer"}},[e._v("www.baidu.com"),n("OutboundLink")],1),e._v("' 这种形式跳转到一个钓鱼网站，泄露用户信息。")])]),e._v(" "),n("p",[e._v('为了避免这样的问题，可以添加引入了 rel="noopener" 属性， 这样新打开的页面便获取不到来源页面的 window 对象了， 此时 window.opener 的值是 null。')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<a href="https://google.com" rel="noopener" target="_blank">Google</a>\n\n')])])]),n("p",[e._v('但是由于一些老的浏览器并不支持 noopener ，通常 noopener 和 noreferrer 会同时设置， rel="noopener noreferrer"。')]),e._v(" "),n("h3",{attrs:{id:"语法-4"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#语法-4"}},[e._v("#")]),e._v(" 语法")]),e._v(" "),n("p",[e._v("回到主题，使用 window.opener 如何实现跨页面通信了。")]),e._v(" "),n("ul",[n("li",[e._v("收集对象")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 收集 window 对象：单个打开页面\nconst windowOpen = window.open('xxx');\n\n// 收集 window 对象：多个打开页面，打开一个页面就需要将打开的 window 对象收集起来，以便于发布广播\nconst windowOpens = [];\nconst windowOpen = window.open('xxx');\nwindowOpens.push(windowOpen);\n\n")])])]),n("ul",[n("li",[e._v("发送消息")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 发送消息：单个页面\nwindowOpen.postMessage(data);\n\n// 发送消息：多个页面\nwindowOpens.forEach((window) => window.postMessage(data));\n接受消息，对于接受消息来说，可能只是接受消息，但是可能接受消息的页面也打开了页面，这种情况需要将消息继续传递下去\nwindow.addEventListener('message', function (e) {\n    const data = e.data;\n    console.log(data);\n    windowOpens.forEach((window) => window.postMessage(data));\n});\n\n")])])]),n("h3",{attrs:{id:"tips-4"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#tips-4"}},[e._v("#")]),e._v(" Tips")]),e._v(" "),n("ol",[n("li",[e._v("在收集到的 window 对象中，可能有的 Tab 窗口被关闭了，这种情况下的 Tab 不需要进行消息传递。")]),e._v(" "),n("li",[e._v("对于接受消息的一方来说，需要继续传递消息，但是这里存在一个问题就是消息回传，可能出现两者之间消息的死循环传递。")]),e._v(" "),n("li",[e._v("这种方式，类似击鼓传花，一个传一个，传递的消息从前往后，一条锁链。")]),e._v(" "),n("li",[e._v("但是如果页面不是通过一个页面打开的，而且直接打开的，或者从三方网站跳转的，那这条锁链将断开。"),n("strong",[e._v("所以这种方式基本只做了解，问题太多，可不做参考。")])])]),e._v(" "),n("p",[e._v("完善的代码如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<button id=\"tab\">新开 Tab</button>\n<button id=\"l-btn\">发送消息</button>\n<script>\n  // 收集 window 对象：多个打开页面，打开一个页面就需要将打开的 window 对象收集起来，以便于发布广播\n  let windowOpens = [];\n  document.getElementById('tab').onclick = function () {\n    // IP 地址为本地的服务\n    const windowOpen = window.open('http://127.0.0.1:5500/CrossPageCommunication/open&opener.html');\n    windowOpens.push(windowOpen);\n  }\n\n  document.getElementById('l-btn').onclick = function () {\n    const data = {};\n    console.log(windowOpens);\n    // 发送消息之前，先进行已关闭 Tab 的过滤\n    windowOpens = windowOpens.filter((window) => !window.closed);\n\n    if (windowOpens.length > 0) {\n      // 数据打一个标记\n      data.tag = false;\n      data.message = '测试，传送消息，我发送消息啦。。。'\n      windowOpens.forEach((window) => window.postMessage(data));\n    }\n    if (window.opener && !window.opener.closed) {\n      data.tag = true;\n      window.opener.postMessage(data);\n    }\n  }\n\n  window.addEventListener('message', function (e) {\n    const data = e.data;\n    console.log('我接受到消息了：', data.message);\n    // 避免消息回传\n    if (window.opener && !window.opener.closed && data.tag) {\n      window.opener.postMessage(data);\n    }\n    // 过滤掉已经关闭的 Tab\n    windowOpens = windowOpens.filter((window) => !window.closed);\n    // 避免消息回传\n    if (windowOpens && !data.tag) {\n      windowOpens.forEach((window) => window.postMessage(data));\n    }\n  });\n<\/script>\n\n")])])]),n("p",[n("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f63a0081c5c4052b4cf27a5be90e599~tplv-k3u1fbpfcp-zoom-1.image",alt:"image.png"}})]),e._v(" "),n("h2",{attrs:{id:"sharedworker"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#sharedworker"}},[e._v("#")]),e._v(" SharedWorker")]),e._v(" "),n("p",[e._v("SharedWorker 接口代表一种特定类型的 worker，可以从几个浏览上下文中访问，例如几个窗口、iframe 或其他 worker。它们实现一个不同于普通 worker 的接口，具有不同的全局作用域, SharedWorkerGlobalScope。")]),e._v(" "),n("h3",{attrs:{id:"语法-5"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#语法-5"}},[e._v("#")]),e._v(" 语法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// 创建共享线程对象\nlet worker = new SharedWorker("./sharedWorker.js");\n\n// 手动启动端口\nworker.port.start();\n\n// 处理从 worker 返回的消息\n worker.port.onmessage = function (val) {\n    ...\n };\n\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<button id=\"tab\">新开 Tab</button>\n<button id=\"l-btn\">点赞</button>\n<p><span id=\"likedCount\">还没有人点赞</span></span>👍</p>\n<script>\n let likedCountEl = document.querySelector(\"#likedCount\");\n\n let worker = new SharedWorker(\"./sharedWorker.js\");\n\n console.log('worker.port', worker.port);\n\n worker.port.start();\n\n // 监听消息\n worker.port.onmessage = function (val) {\n   likedCountEl.innerHTML = val.data;\n };\n\n document.getElementById('tab').onclick = function () {\n   // IP 地址为本地起的服务\n   const windowOpen = window.open('http://127.0.0.1:5500/CrossPageCommunication/sharedWorker/index.html');\n }\n\n document.getElementById('l-btn').onclick = function () {\n   worker.port.postMessage('点赞了');\n };\n<\/script>\n// ./sharedWorker.js\nlet a = 666;\n\nconsole.log('shared-worker');\nonconnect = function (e) {\n const port = e.ports[0];\n console.log('shared-worker connect');\n\n // 不能使用这种方式监听事件\n // port.addEventListener('message', () => {\n //   port.postMessage(++a);\n // });\n\n port.postMessage(a);\n\n port.onmessage = () => {\n   port.postMessage(++a);\n };\n console.log('当前点赞次数:', a);\n};\n\n")])])]),n("p",[n("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa5d1912da564ad3ae180b8e1fd85b97~tplv-k3u1fbpfcp-zoom-1.image",alt:"image.png"}})]),e._v(" "),n("h3",{attrs:{id:"tips-5"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#tips-5"}},[e._v("#")]),e._v(" Tips")]),e._v(" "),n("ol",[n("li",[e._v("如果要使 SharedWorker 连接到多个不同的页面，这些页面必须是同源的（相同的协议、host 以及端口）。")]),e._v(" "),n("li",[e._v("Shared Worker 在实现跨页面通信时的，它无法主动通知所有页面，需要刷新页面或者是定时任务来检查是否有新的消息。在例子中我是手动刷新的，当然可以使用 setInterval 来定时刷新。")]),e._v(" "),n("li",[e._v("如果需要调试 SharedWorker，使用 chrome://inspect/#workers")])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bcd88e763984dedaa06d959ccab62df~tplv-k3u1fbpfcp-zoom-1.image",alt:"image.png"}})]),e._v(" "),n("p",[n("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce57702bb83d4b188bec2192054cbaa6~tplv-k3u1fbpfcp-zoom-1.image",alt:"image.png"}})]),e._v(" "),n("ol",[n("li",[e._v("sharedWorker.js 不能使用 .addEventListener 来监听 message 事件，监听无效。 兼容性一般。")])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/952b571f96864f19a19c07045994789f~tplv-k3u1fbpfcp-zoom-1.image",alt:"image.png"}})]),e._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("p",[e._v("在上面列举了五种前端跨页面通信的方式，当然对前端来说远远不止这五种方式，还有其他方案例如：使用 hashchange、cookie、Websocket、postMessage 都是可以的。文章中只是列举了部分。并且文章中的方案都是针对同源的 Tab。")]),e._v(" "),n("p",[e._v("文章的前三种解决方式不论是 Broadcast Channel，还是 Service Worker ，或是 storage 事件，其都是“广播模式”：一个页面将消息通知给一个“中央站”，再由“中央站”通知给各个页面。")]),e._v(" "),n("p",[e._v("而对于 open & opener 这种方式，类似击鼓传花，一个传一个，传递的消息从前往后，一条锁链。但是如果页面不是通过一个页面打开的，而且直接打开的，或者从三方网站跳转的，那这条锁链将断开。")]),e._v(" "),n("p",[e._v("Shared Worker 的最大问题在于实现跨页面通信时的，它无法主动通知所有页面，需要刷新页面或者是定时任务来检查是否有新的消息，也就是需要配合轮询来使用。")]),e._v(" "),n("p",[e._v("最终在我们团队对于前端跨页面通信最后选择的解决方案是使用 onstorage，主要考量的三个方面：")]),e._v(" "),n("ul",[n("li",[e._v("兼容性。浏览器支持度。")]),e._v(" "),n("li",[e._v("通用性。能否覆盖需求、是否具有拓展性。")]),e._v(" "),n("li",[e._v("便捷性。开发便捷程度。")])]),e._v(" "),n("p",[e._v("其他方案在这三个方面来说都或多或少存在一些美中不足。")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.cn/post/7081516964400594951",target:"_blank",rel:"noopener noreferrer"}},[e._v("转载于掘金"),n("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=o.exports}}]);