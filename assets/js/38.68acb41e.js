(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{501:function(e,t,a){"use strict";a.r(t);var n=a(2),r=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"前端录屏"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端录屏"}},[e._v("#")]),e._v(" 前端录屏")]),e._v(" "),t("h2",{attrs:{id:"使用-webrtc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-webrtc"}},[e._v("#")]),e._v(" 使用 WebRTC")]),e._v(" "),t("blockquote",[t("p",[e._v("WebRTC (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC 包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。")])]),e._v(" "),t("h3",{attrs:{id:"使用方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用方式"}},[e._v("#")]),e._v(" 使用方式")]),e._v(" "),t("ol",[t("li",[e._v("在页面上放置几个按钮。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<body>\n  <button id="start">屏幕分享</button>\n  <button id="record">开始录制</button>\n  <button id="stop">结束录制</button>\n  <button id="download">下载视频</button>\n  <video autoplay playsinline id="player"></video>\n  <script src="./index.js"><\/script>\n</body>\n复制代码\n')])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("点击按钮之后执行对应方法。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 核心代码如下，具体示例可见下方 github\nlet buffer = [], // 存储录制视频的data数据段\n  mediaRecorder, // new MediaRecorder 的实例对象\n  allStream; // navigator.mediaDevices.getDisplayMedia 返回的stream\n\nclass WebRTCAction {\n  start() {\n    // ...\n    navigator.mediaDevices\n      .getDisplayMedia({\n        video: true,\n        audio: false,\n      })\n      .then(stream => {\n        allStream = stream;\n        document.querySelector('#player').srcObject = stream;\n      })\n      .catch(err => {\n        console.error(err);\n      });\n  }\n  record() {\n    const options = {\n      mimeType: 'video/webm;codecs=vp8',\n    };\n    // 判断是否是支持的mimeType格式\n    if (!MediaRecorder.isTypeSupported(options.mimeType)) {\n      console.error('不支持的视频格式');\n      return;\n    }\n    try {\n      mediaRecorder = new MediaRecorder(allStream, options);\n      // 处理采集到的事件\n      mediaRecorder.ondataavailable = function(e) {\n        if (e && e.data && e.data.size > 0) {\n          // 存储到数组中\n          buffer.push(e.data);\n        }\n      };\n      // 开始录制\n      mediaRecorder.start(10);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n  download() {\n    mediaRecorder.stop();\n    // ...\n  }\n  stop() {\n    //...\n  }\n}\n\nconst webAction = new WebRTCAction();\n复制代码\n")])])]),t("h3",{attrs:{id:"实现效果预览"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现效果预览"}},[e._v("#")]),e._v(" 实现效果预览")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82848d5fe4ae408fa8aaa2cec16f2f1b~tplv-k3u1fbpfcp-zoom-1.image",alt:"record-1"}})]),e._v(" "),t("blockquote",[t("p",[e._v("整体代码见 github: "),t("a",{attrs:{href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FHuhui-coder%2FwebRTC-demo",title:"https://github.com/Huhui-coder/webRTC-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("webRTC-demo"),t("OutboundLink")],1)])]),e._v(" "),t("h3",{attrs:{id:"简析原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简析原理"}},[e._v("#")]),e._v(" 简析原理")]),e._v(" "),t("h4",{attrs:{id:"webrtc-点对点通信流程图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webrtc-点对点通信流程图"}},[e._v("#")]),e._v(" webRTC 点对点通信流程图")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da67c32c4bd4476fba4f728d74a457e5~tplv-k3u1fbpfcp-zoom-1.image",alt:"webRTC流程图"}})]),e._v(" "),t("ol",[t("li",[e._v("PeerA 与 PeerB 通过信令服务器进行媒体协商，如双方使用的音视频编码格式。双方交换的媒体数据由 SDP 协议描述。")]),e._v(" "),t("li",[e._v("PeerA 与 PeerB 通过 STUN 服务器获取到各自自己的网络信息，如 IP 和端口。然后通过信令服务器转发互相交换各种的网络信息。这样双方就知道对方的 IP 和端口了，即 P2P 打洞成功建立直连。这个过程涉及到 NAT 及 ICE 协议，具体后面会详细描述。")]),e._v(" "),t("li",[e._v("PeerA 与 PeerB 如果没有建立起直连，则通过 TURN 中转服务器转发音视频数据，最终完成音视频通话。")])]),e._v(" "),t("h3",{attrs:{id:"优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[e._v("#")]),e._v(" 优缺点")]),e._v(" "),t("p",[e._v("优点")]),e._v(" "),t("ul",[t("li",[e._v("使用简单，API 较为简单，可将录屏获得的数据转为视频资源，进行 OSS 直传。")]),e._v(" "),t("li",[e._v("跨平台(Web、Windows、MacOS、Linux、iOS、Android)")])]),e._v(" "),t("p",[e._v("不足之处")]),e._v(" "),t("ul",[t("li",[e._v("用户可操作性太大，且是由用户进行录屏窗口的选择，无法做到用户无感知录制，录制之后为视频资源，占据比较大的存储空间。")])]),e._v(" "),t("h2",{attrs:{id:"使用-rrweb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-rrweb"}},[e._v("#")]),e._v(" 使用 rrweb")]),e._v(" "),t("blockquote",[t("p",[e._v("rrweb 是 'record and replay the web' 的简写，旨在利用现代浏览器所提供的强大 API 录制并回放任意 web 界面中的用户操作。")])]),e._v(" "),t("h3",{attrs:{id:"使用方式-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用方式-2"}},[e._v("#")]),e._v(" 使用方式")]),e._v(" "),t("ol",[t("li",[e._v("通过 "),t("code",[e._v("yarn")]),e._v(" 下载 "),t("code",[e._v("rrweb")]),e._v("。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("yarn add rrweb -S\n复制代码\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("通过 "),t("code",[e._v("yarn")]),e._v(" 下载 "),t("code",[e._v("rrweb-player")]),e._v(" 。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("yarn add rrweb-player -S\n复制代码\n")])])]),t("p",[e._v("下面是官网上提供的最简单实践方式。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let events = [];\n\nrrweb.record({\n  emit(event) {\n    // 将 event 存入 events 数组中\n    events.push(event);\n  },\n});\n\n// save 函数用于将 events 发送至后端存入，并重置 events 数组\nfunction save() {\n  const body = JSON.stringify({ events });\n  events = [];\n  fetch('http://YOUR_BACKEND_API', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body,\n  });\n}\n\n// 每 10 秒调用一次 save 方法，避免请求过多\nsetInterval(save, 10 * 1000);\n复制代码\n")])])]),t("p",[e._v("对于 "),t("code",[e._v("webshell")]),e._v(" 的录屏方式，我们需要配置 "),t("code",[e._v("rrweb")]),e._v(" 使其支持 "),t("code",[e._v("canvas")]),e._v(" 的录制，并且为了使其更易用，我们需要在录制时做到将数据进行压缩并且进行分片上传。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let timer: NodeJS.Timeout | null = null;\nconst recodeEvents = useRef([]);\nimport { zip } from 'js-zip';\n\n/**\n *  开始录屏，并存储 events 数据，开启 canvas 录制、允许下载 canvas 中的字体文件\n *\n */\nconst startRecord = () => {\n  stopFn = rrweb.record({\n    emit(event) {\n      recodeEvents.current.push(event);\n    },\n    recordCanvas: true,\n    collectFonts: true,\n  });\n\n  timer = setInterval(saveRecord, 3 * 1000);\n};\n/**\n *  压缩 events 数据，并上传至后端\n *\n */\nconst saveRecord = async () => {\n  if (timer) {\n    let events = recodeEvents.current;\n    recodeEvents.current = [];\n    let video_data = zip(JSON.stringify({ events }));\n    video_data = video_data.toString();\n    const param = {\n      id: currentVideoId,\n      video_data,\n    };\n    await YOURUPLOADFUNCTION(param);\n  }\n};\n复制代码\n")])])]),t("h3",{attrs:{id:"实现效果预览-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现效果预览-2"}},[e._v("#")]),e._v(" 实现效果预览")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f77b70b1921f469f92a1f76ab0764ed2~tplv-k3u1fbpfcp-zoom-1.image",alt:"record-8"}})]),e._v(" "),t("blockquote",[t("p",[e._v("整体代码见 github: "),t("a",{attrs:{href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FHuhui-coder%2Frrweb-demo",title:"https://github.com/Huhui-coder/rrweb-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("rrweb-demo"),t("OutboundLink")],1)])]),e._v(" "),t("h3",{attrs:{id:"简析原理-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简析原理-2"}},[e._v("#")]),e._v(" 简析原理")]),e._v(" "),t("h4",{attrs:{id:"rrweb-录制视频流程图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rrweb-录制视频流程图"}},[e._v("#")]),e._v(" rrweb 录制视频流程图")]),e._v(" "),t("h4",{attrs:{id:"录制部分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#录制部分"}},[e._v("#")]),e._v(" 录制部分")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2afd97b1b1041d891a16a8372b9c8ed~tplv-k3u1fbpfcp-zoom-1.image",alt:"img"}})]),e._v(" "),t("p",[e._v("当用户打开 "),t("code",[e._v("webshell")]),e._v(" 界面之后，前端逻辑代码会自动开始“录制”当前界面，用户是无感知的，并执行轮询上传数据的接口，为了保证数据的实时性，程序中采用的是轮询的方式，如果采用当关闭 "),t("code",[e._v("webshell")]),e._v(" 之后，一次性上传所有的录制数据，会导致上传数据量过大，如果该接口请求失败了，那么整段数据将不复存在。并且还采用了 "),t("code",[e._v("gzip")]),e._v(" 算法进行数据的压缩，保证不存在大数据量的 "),t("code",[e._v("http")]),e._v(" 传输。")]),e._v(" "),t("h4",{attrs:{id:"回放部分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回放部分"}},[e._v("#")]),e._v(" 回放部分")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2df1578e3a454c4c89fc80640f98bdde~tplv-k3u1fbpfcp-zoom-1.image",alt:"img"}})]),e._v(" "),t("p",[e._v("回放相对来说简单一些，由于我们上传的录制数据是经过 "),t("code",[e._v("gzip")]),e._v(" 算法压缩过的，所以数据量会特别的小，我们采用一次性请求全部的 "),t("code",[e._v("JSON")]),e._v(" 数据段，再进行 "),t("code",[e._v("gzip")]),e._v(" 的解压缩，再将播放器界面渲染出来即可完成播放的一系列操作。")]),e._v(" "),t("h3",{attrs:{id:"优缺点-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优缺点-2"}},[e._v("#")]),e._v(" 优缺点")]),e._v(" "),t("p",[e._v("优点: 是业界方案，github star 数量较多，值得信赖，能够实现用户无感知录屏，并且可以很方便的实现用户操作的复现。")]),e._v(" "),t("p",[e._v("不足之处: 对于特殊场景的支持不够友好，比如对于存在 pdf 的场景下，就会表现的十分卡顿。")]),e._v(" "),t("h2",{attrs:{id:"最终实践方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最终实践方案"}},[e._v("#")]),e._v(" 最终实践方案")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"center"}},[e._v("标准")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("webRTC")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("rrweb")])])]),e._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("完整录制屏幕")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("√")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("√")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("跨平台使用")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("√")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("√")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("用户对“录制”操作无感知")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("×")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("√")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("录制可回放，方便存储")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("×")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("√")])])])]),e._v(" "),t("p",[e._v("综上所述，鉴于 "),t("code",[e._v("rrweb")]),e._v(" 的优秀录制视频还原能力，以及实现用户无感知录制能力，且不存在录制 "),t("code",[e._v("pdf")]),e._v(" 的场景，避免了目前使用 "),t("code",[e._v("rrweb")]),e._v(" 会造成卡顿的场景 ，最终实现方案选择了 "),t("code",[e._v("rrweb")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"rrweb-原理详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rrweb-原理详解"}},[e._v("#")]),e._v(" rrweb 原理详解")]),e._v(" "),t("h4",{attrs:{id:"技术流程图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#技术流程图"}},[e._v("#")]),e._v(" 技术流程图")]),e._v(" "),t("p",[t("code",[e._v("rrweb")]),e._v(" 主要由三部分组成 "),t("code",[e._v("rrweb")]),e._v("、"),t("code",[e._v("rrweb-snapshot")]),e._v("、"),t("code",[e._v("rrweb-player")]),e._v(" 。")]),e._v(" "),t("h5",{attrs:{id:"录制原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#录制原理"}},[e._v("#")]),e._v(" 录制原理")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f55b8d8e94e8466eb5669efb016da1f5~tplv-k3u1fbpfcp-zoom-1.image",alt:"录制原理"}})]),e._v(" "),t("p",[t("code",[e._v("rrweb")]),e._v(" 在录制时会首先进行首屏 "),t("code",[e._v("DOM")]),e._v(" 快照，遍历整个页面的 "),t("code",[e._v("DOM Tree")]),e._v(" 并通过 "),t("code",[e._v("nodeType")]),e._v(" 映射转换为 "),t("code",[e._v("JSON")]),e._v(" 结构数据，同时针对增量改变的数据同步转换为 "),t("code",[e._v("JSON")]),e._v(" 数据进行存储。整个录制的过程会生成 "),t("code",[e._v("unique id")]),e._v(" 来确定增量数据所对应的 "),t("code",[e._v("DOM")]),e._v(" 节点，通过 "),t("code",[e._v("timestamp")]),e._v(" 保证回放顺序。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46f0df9f6d084da2aaf3c2256530b462~tplv-k3u1fbpfcp-zoom-1.image",alt:"全屏快照原理图"}})]),e._v(" "),t("p",[e._v("对于首屏快照后的增量数据更新，则是通过 "),t("code",[e._v("mutationObserver")]),e._v(" 获取 "),t("code",[e._v("DOM")]),e._v(" 增量变化，通过全局事件监听、事件（属性）代理的方式进行方法（属性）劫持，并将劫持到的增量变化数据存入 "),t("code",[e._v("JSON")]),e._v(" 数据中。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a08c32b6a5b4336b081155814802a3a~tplv-k3u1fbpfcp-zoom-1.image",alt:"增量更新"}})]),e._v(" "),t("h5",{attrs:{id:"回放原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回放原理"}},[e._v("#")]),e._v(" 回放原理")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de3921f04e844ed99e771983c96eb4c6~tplv-k3u1fbpfcp-zoom-1.image",alt:"回放原理图"}})]),e._v(" "),t("p",[e._v("首先针对首屏 "),t("code",[e._v("DOM")]),e._v(" 快照进行重建，在遍历 "),t("code",[e._v("JSON")]),e._v(" 产物的同时通过自定义 "),t("code",[e._v("type")]),e._v(" 映射到不同的节点构建方法，重建首屏的 "),t("code",[e._v("DOM")]),e._v(" 结构。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4adc0d17e17842b19f04f003c3e8e50a~tplv-k3u1fbpfcp-zoom-1.image",alt:"增量回放"}})]),e._v(" "),t("h4",{attrs:{id:"dom-快照"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dom-快照"}},[e._v("#")]),e._v(" DOM 快照")]),e._v(" "),t("p",[e._v("实际上， ⻚⾯中的视图状态可以通过 "),t("code",[e._v("DOM")]),e._v(" 树的形式描述，所以当我们尝试录制⼀个⻚⾯时，我们可以记录 "),t("code",[e._v("DOM")]),e._v(" 树在各个时间点上的状态。 记录每一时刻页面的 "),t("code",[e._v("DOM")]),e._v(" 状态，回放的时候根据时间点显示即可。")]),e._v(" "),t("p",[e._v("简单实现一个记录当前状态。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 克隆当前的 document 元素\nconst docEl = document.documentElement.cloneNode(true);\n// 替换\ndocument.replaceChild(docEl, document.documentElement);\n复制代码\n")])])]),t("p",[e._v("我们通过上述方式获取到的是当前 "),t("code",[e._v("DOM")]),e._v(" 的状态。")]),e._v(" "),t("p",[e._v("但是，每一时刻都记录全量数据会导致数据量过于大，不便于存储。")]),e._v(" "),t("p",[e._v("于是，"),t("code",[e._v("rrweb")]),e._v(" 采用的方式是通过 "),t("code",[e._v("DOM")]),e._v(" 快照。")]),e._v(" "),t("p",[e._v("记录初始页面的 "),t("code",[e._v("DOM")]),e._v(" 状态，或者特定某个时刻的 "),t("code",[e._v("DOM")]),e._v(" 状态， 后续收集的是不同时间点的操作指令 或者 某个时刻 某个 "),t("code",[e._v("DOM")]),e._v(" 的变化作为一个增量快照， 在原先快照的基础上，不断加入根据行为解析的 "),t("code",[e._v("DOM")]),e._v(" 数据，构建了后续的快照，减少大量数据的存储或传输。")]),e._v(" "),t("p",[e._v("我们获取到的 "),t("code",[e._v("DOM")]),e._v(" 快照是一个 "),t("code",[e._v("DOM")]),e._v(" 节点数据，并不是可序列化的，我们不能将其转化为可方便传输的数据，也就无法上传到服务器，无法实现远程录制的功能。")]),e._v(" "),t("h4",{attrs:{id:"rrweb-snapshot"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rrweb-snapshot"}},[e._v("#")]),e._v(" rrweb-snapshot")]),e._v(" "),t("p",[e._v("在 "),t("code",[e._v("rrweb")]),e._v(" 中，是通过 "),t("code",[e._v("rrweb-snapshot")]),e._v(" 来实现上述功能的。")]),e._v(" "),t("p",[t("code",[e._v("rrweb-snapshot")]),e._v(" 包含 两部分")]),e._v(" "),t("ol",[t("li",[e._v("snapshot： 将 "),t("code",[e._v("DOM")]),e._v(" 及其状态转化为可序列化的数据结构并添加唯一标识")]),e._v(" "),t("li",[e._v("rebuild： 将 "),t("code",[e._v("snapshot")]),e._v(" 记录的数据结构重建为对应的 "),t("code",[e._v("DOM")]),e._v("。")])]),e._v(" "),t("h5",{attrs:{id:"snapshot-实现细节"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#snapshot-实现细节"}},[e._v("#")]),e._v(" snapshot 实现细节")]),e._v(" "),t("ol",[t("li",[e._v("构建页面 "),t("code",[e._v("DOM")]),e._v(" 树，为每一个 "),t("code",[e._v("Node")]),e._v(" 节点都绑定了一个唯一 "),t("code",[e._v("id")]),e._v(" , 这个映射只要是为了方便后续的增量快照操作。")]),e._v(" "),t("li",[e._v("将 "),t("code",[e._v("href")]),e._v(" ，"),t("code",[e._v("src")]),e._v(" ，"),t("code",[e._v("CSS")]),e._v(" 中的相对路径设为绝对路径 将一些脚本，样式，图片等引用的相对路径改为绝对路径。")]),e._v(" "),t("li",[e._v("将页面引用的样式变为内联样式，以确保可以使用本地样式 将页面引用的样式读取变为内联样式。")]),e._v(" "),t("li",[e._v("将一些 "),t("code",[e._v("DOM")]),e._v(" 状态内联到 "),t("code",[e._v("HTML")]),e._v(" 属性中，例如 "),t("code",[e._v("HTMLInputElement")]),e._v(" 的值 记录没有反映在 "),t("code",[e._v("HTML")]),e._v(" 中的视图状态。例如 输⼊后的值不会反映在其 "),t("code",[e._v("HTML")]),e._v(" 中，我们需要读取其 "),t("code",[e._v("value")]),e._v(" 值并加以记录。")]),e._v(" "),t("li",[e._v("将 "),t("code",[e._v("script")]),e._v(" 标记转换为 "),t("code",[e._v("noscript")]),e._v(" 标记，以避免脚本被执行 在播放录制页面时，页面的脚本是不能够被执行的，需要禁掉。")])]),e._v(" "),t("h5",{attrs:{id:"rebuild-实现细节"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rebuild-实现细节"}},[e._v("#")]),e._v(" rebuild 实现细节")]),e._v(" "),t("ol",[t("li",[e._v("通过创建 "),t("code",[e._v("DOM")]),e._v(" , 设置属性，将 "),t("code",[e._v("snapshot")]),e._v(" 生成的数据再转化成对应的 "),t("code",[e._v("DOM")]),e._v(" 插入文档中。")])]),e._v(" "),t("p",[e._v("上面我们将需要生成的数据已经处理好了，那么接下来就要处理录制的问题了。")]),e._v(" "),t("h4",{attrs:{id:"rrweb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rrweb"}},[e._v("#")]),e._v(" rrweb")]),e._v(" "),t("p",[e._v("我们上面有说过是通过增量快照的形式来进行记录数据的一个变化的。在 "),t("code",[e._v("rrweb")]),e._v(" 中 是通过 "),t("code",[e._v("rrweb")]),e._v(" 仓库来实现的，包含两部分 "),t("code",[e._v("record")]),e._v(", 和 "),t("code",[e._v("replay")]),e._v(" 。")]),e._v(" "),t("ol",[t("li",[e._v("record: 用于记录 "),t("code",[e._v("DOM")]),e._v(" 中的所有变更（mutation）")]),e._v(" "),t("li",[e._v("replay: 则是将记录的变更按照对应的时间一一重放")])]),e._v(" "),t("h5",{attrs:{id:"record-实现细节"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#record-实现细节"}},[e._v("#")]),e._v(" record 实现细节")]),e._v(" "),t("ol",[t("li",[e._v("record 会监听用户的行为来记录相关的数据。")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("DOM 变动")]),e._v(" "),t("ul",[t("li",[e._v("节点创建、销毁")]),e._v(" "),t("li",[e._v("节点属性变化")]),e._v(" "),t("li",[e._v("文本变化")])])]),e._v(" "),t("li",[t("p",[e._v("鼠标移动")])]),e._v(" "),t("li",[t("p",[e._v("鼠标交互")]),e._v(" "),t("ul",[t("li",[e._v("mouse up、mouse down")]),e._v(" "),t("li",[e._v("click、double click、context menu")]),e._v(" "),t("li",[e._v("focus、blur")]),e._v(" "),t("li",[e._v("touch start、touch move、touch end")])])]),e._v(" "),t("li",[t("p",[e._v("页面或元素滚动")])]),e._v(" "),t("li",[t("p",[e._v("视窗大小改变")])]),e._v(" "),t("li",[t("p",[e._v("输入")])])]),e._v(" "),t("h6",{attrs:{id:"mutationobserver"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mutationobserver"}},[e._v("#")]),e._v(" MutationObserver")]),e._v(" "),t("p",[e._v("其中监听 DOM 变化使用的 API 为 "),t("code",[e._v("MutationObserver")]),e._v("。")]),e._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FMutationObserver",title:"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("MutationObserver")]),t("OutboundLink")],1),e._v("接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。")])]),e._v(" "),t("p",[e._v("当监视的 "),t("code",[e._v("DOM")]),e._v(" 发生变动时, "),t("code",[e._v("MutationObserver")]),e._v(" 将收到通知并触发预先设定好的回调参数，与 "),t("code",[e._v("addEventListener")]),e._v(" 方法 比较相似。")]),e._v(" "),t("p",[e._v("当我们尝试改变页面 "),t("code",[e._v("DOM")]),e._v(" 的属性，或者新增 "),t("code",[e._v("DOM")]),e._v(" 节点的时候，都会对应生成一条 "),t("code",[e._v("mutationObserver record")]),e._v(", "),t("code",[e._v("record")]),e._v(" 记录了一些变动信息。 在 "),t("code",[e._v("rrweb")]),e._v(" 中， 对每一条 "),t("code",[e._v("mutation record")]),e._v("做了以下处理。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private processMutation = (m: mutationRecord) => {\n    //  首先判断是否为忽略的 DOM 节点\n    if (isIgnored(m.target)) {\n      return;\n    }\n    // 判断节点类型\n    switch (m.type) {\n        // ...\n      case 'attributes': {\n        const target = m.target as HTMLElement;\n        let value = (m.target as HTMLElement).getAttribute(m.attributeName!);\n        // 对 input 标签中的 value 属性进行处理\n        if (m.attributeName === 'value') {\n          value = maskInputValue({\n            maskInputOptions: this.maskInputOptions,\n            tagName: (m.target as HTMLElement).tagName,\n            type: (m.target as HTMLElement).getAttribute('type'),\n            value,\n            maskInputFn: this.maskInputFn,\n          });\n        }\n        // 判断是否为不需要监听变化的 DOM 节点\n        if (isBlocked(m.target, this.blockClass) || value === m.oldValue) {\n          return;\n        }\n        // ...\n        break;\n      }\n    // ...\n    }\n  };\n\n  public processMutations = (mutations: mutationRecord[]) => {\n    mutations.forEach(this.processMutation);\n    this.emit();\n  };\n复制代码\n")])])]),t("p",[e._v("针对不同的类型进行处理， "),t("code",[e._v("characterData")]),e._v(" 是节点内容或节点文本变动，"),t("code",[e._v("attributes")]),e._v(" 是节点属性的变动，"),t("code",[e._v("childList")]),e._v(" 是子节点的变动，包括新增子节点，移除子节点，移动子节点等。")]),e._v(" "),t("h6",{attrs:{id:"addeventlisteners"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#addeventlisteners"}},[e._v("#")]),e._v(" addEventListeners")]),e._v(" "),t("p",[e._v("其中监听 "),t("strong",[e._v("鼠标移动，鼠标交互，页面滚动，视窗大小")]),e._v(" 使用的 API 为 "),t("strong",[e._v("事件绑定")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 实现 addEventListeners 逻辑的核心代码\nexport function on(\n    type: string,\n    fn: EventListenerOrEventListenerObject,\n    target: Document | IWindow = document,\n  ): listenerHandler {\n    const options = { capture: true, passive: true };\n    target.addEventListener(type, fn, options);\n    return () => target.removeEventListener(type, fn, options);\n  }\n\n  // 监听 页面滚动 的核心代码\n  export function initScrollObserver(\n    cb: scrollCallback,\n    doc: Document,\n    mirror: Mirror,\n    blockClass: blockClass,\n    sampling: SamplingStrategy,\n  ): listenerHandler {\n    const updatePosition = throttle<UIEvent>((evt) => {\n      const target = getEventTarget(evt);\n      if (!target || isBlocked(target as Node, blockClass)) {\n        return;\n      }\n      const id = mirror.getId(target as INode);\n      // ...\n    }, sampling.scroll || 100);\n    return on('scroll', updatePosition, doc);\n  }\n\n\n复制代码\n")])])]),t("h5",{attrs:{id:"replay-实现细节"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#replay-实现细节"}},[e._v("#")]),e._v(" replay 实现细节")]),e._v(" "),t("ol",[t("li",[e._v("解析收集到的 "),t("code",[e._v("events")]),e._v(" 集合。")]),e._v(" "),t("li",[e._v("当事件类型为 "),t("code",[e._v("FullSnapshot")]),e._v(" 时，会调用 "),t("code",[e._v("rebuild")]),e._v(", 根据快照数据生成页面的 "),t("code",[e._v("DOM")]),e._v(", 当事件类型为 "),t("code",[e._v("IncrementalSnapshot")]),e._v(" 时，则说明是增量快照，即收集的数据只是 "),t("code",[e._v("DOM")]),e._v(" 的变化数据或者对应的用户行为数据，根据不同的数据类型做对应的节点插入，删除，节点属性的更改等。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  const firstFullsnapshot = this.service.state.context.events.find(\n      (e) => e.type === EventType.FullSnapshot,\n    );\n\n if (firstFullsnapshot) {\n      setTimeout(() => {\n        // 判断是否为 FullSnapshot\n        if (this.firstFullSnapshot) {\n          return;\n        }\n        this.firstFullSnapshot = firstFullsnapshot;\n        this.rebuildFullSnapshot(\n          firstFullsnapshot as fullSnapshotEvent & { timestamp: number },\n        );\n        this.iframe.contentWindow!.scrollTo(\n          (firstFullsnapshot as fullSnapshotEvent).data.initialOffset,\n        );\n      }, 1);\n    }\n\n复制代码\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private getCastFn(event: eventWithTime, isSync = false) {\n    // 判断 type 类型 是否为 IncrementalSnapshot\n   case EventType.IncrementalSnapshot:\n           castFn = () => {\n             // 调用 applyIncremental 函数\n             this.applyIncremental(event, isSync);\n             if (isSync) {\n               return;\n             }\n           };\n           break;\n         default:\n\n       //...\n}\n\n// applyIncremental 函数具体实现\n// 其中 incrementalSnapshotEvent 代表增量数据，其具体增量类型可以通过 `event.data.source` 字段进行判断：\nprivate applyIncremental(\n    e: incrementalSnapshotEvent & { timestamp: number; delay?: number },\n    isSync: boolean,\n  ) {\n    const { data: d } = e;\n    // 判断增量类型\n    switch (d.source) {\n      // ...\n      case IncrementalSource.Mutation: {\n        if (isSync) {\n          d.adds.forEach((m) => this.treeIndex.add(m));\n          d.texts.forEach((m) => this.treeIndex.text(m));\n          d.attributes.forEach((m) => this.treeIndex.attribute(m));\n          d.removes.forEach((m) => this.treeIndex.remove(m, this.mirror));\n        }\n        try {\n          this.applyMutation(d, isSync);\n        } catch (error) {\n          this.warn(`Exception in mutation ${error.message || error}`, d);\n        }\n        break;\n      }\n      // ...\n      default:\n    }\n  }\n复制代码\n")])])]),t("h2",{attrs:{id:"沙箱回放还是录制视频存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#沙箱回放还是录制视频存储"}},[e._v("#")]),e._v(" 沙箱回放还是录制视频存储？")]),e._v(" "),t("p",[e._v("在录制数据中，有许多的外链资源，比如 cdn 的文件，外链的图片等等，也就是说在我们利用录制的数据进行回放的时候，需要依赖这张图片。但是随着项目的迭代，这张图片很可能早已不在，这时我们在回放时，页面中的图片就会加载不出来。比如一个保险场景，保额信息就在网站内的一张海报上，客户可能会说：“我当时看到的保额明明是 150 万，怎么现在变成 100 万了？”，这时你要怎么证明当时海报上写的就是 100 万保额呢？")]),e._v(" "),t("p",[e._v("所以最稳妥的方案还是将 rrweb 录制的原始数据转换成视频，这样一来，不管网站怎么变化，迭代了多少版本，视频是不受影响的。我的做法是通过 puppeteer 在服务端运行无头浏览器，在无头浏览器中回放录制的数据，然后每秒截取一定数量的图片，最后通过 ffmpeg 合成视频。")]),e._v(" "),t("p",[e._v("当然这里 rrweb官方也有提供一些解决方案，比如后端可以在每次数据上传以后将外链资源扫描出来，然后存在本地服务器端，这样子可以保证拥有对资源的控制权。这里就按照各自的具体场景决定了")]),e._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("其实，前端实现录制能力可以实现很多比较实用的功能。")]),e._v(" "),t("p",[e._v("比如： 当你在处理线上问题的时候，由于环境的影响、用户数据和浏览器版本等等原因而不能快速复现时，那么使用 "),t("code",[e._v("rrweb")]),e._v("来实现一套前端监控系统就显得十分的有必要了。目前业内已经有比较合适的方案了，开源的有"),t("code",[e._v("Sentry")]),e._v("， 商业化的有"),t("code",[e._v("fundebug")]),e._v("。")]),e._v(" "),t("p",[e._v("比如： 当你需要将用户的操作进行回溯时，那么使用"),t("code",[e._v("rrweb")]),e._v("等方案实现前端录制就是一个很好的选择。")]),e._v(" "),t("p",[e._v("...")]),e._v(" "),t("p",[e._v("系统使用 "),t("code",[e._v("rrweb")]),e._v(" 来实现前端录屏操作还只是众多可应用方面的一个实践而已，所以，掌握好 "),t("code",[e._v("WebRTC")]),e._v(" 或 "),t("code",[e._v("rrweb")]),e._v(" 这种类似的技术还是十分有必要的。")])])}),[],!1,null,null,null);t.default=r.exports}}]);